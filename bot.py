# -*- coding: utf-8 -*-
"""bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qGU_uW5oSECZpx5JuKff0xU4t1sCHpFA
"""

import pandas as pd
df= pd.read_csv('')

import csv
import json

# Convert training CSV to JSON
with open(r'C:\Users\User\Desktop\Datasets\Menstrual health data\Training_data.csv', mode='r') as csv_file:
    csv_reader = csv.DictReader(csv_file)  # Use 'csv_file' here
    training_data = [row for row in csv_reader]

# Save JSON output to a file
with open('training_data.json', 'w') as json_file:
    json.dump(training_data, json_file, indent=4)  # Dump only once

import csv
import json

# Convert testing CSV to JSON
with open(r'C:\Users\User\Desktop\Datasets\Menstrual health data\Testing_data.csv', mode='r') as csv_file:
    csv_reader = csv.DictReader(csv_file)  # Use 'csv_file' here
    testing_data = [row for row in csv_reader]

# Save JSON output to a file
with open('testing_data.json', 'w') as json_file:
    json.dump(testing_data, json_file, indent=4)  # Dump only once

import json

# Load training data
with open('training_data.json', 'r') as json_file:
    training_data = json.load(json_file)

# Load testing data
with open('testing_data.json', 'r') as json_file:
    testing_data = json.load(json_file)

# Now training_data and testing_data are available as Python lists (or dictionaries)

import os
import nltk
import ssl
import streamlit as st
import random
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression

ssl.create_default_https_context=ssl._create_unverified_context
nltk.data.path.append(os.path.abspath("nltk_data"))
nltk.download('punkt')

tags = []
patterns = []

for entry in training_data:
    patterns.append(entry['instruction (string)'])  # Use the exact key
    tags.append(entry['output (string)'])            # Use the exact key

# Print the first few entries to inspect the structure
print(json.dumps(training_data, indent=4)[:1000])  # Print the first 1000 characters for inspection

from sklearn.metrics import accuracy_score
train_patterns = []
train_tags = []

for entry in training_data:
    train_patterns.append(entry['instruction (string)'])  # Adjust key name if needed
    train_tags.append(entry['output (string)'])            # Adjust key name if needed

# Preprocess testing data
test_patterns = []
test_tags = []

for entry in testing_data:
    test_patterns.append(entry['instruction (string)'])  # Adjust key name if needed
    test_tags.append(entry['output (string)'])            # Adjust key name if needed

# Vectorization
vectorizer = TfidfVectorizer()
X_train = vectorizer.fit_transform(train_patterns)  # Vectorize training instructions
y_train = train_tags                                  # Outputs for training

X_test = vectorizer.transform(test_patterns)        # Vectorize testing instructions
y_test = test_tags                                   # Outputs for testing

# Train the Model
clf = LogisticRegression(random_state=0, max_iter=10000)
clf.fit(X_train, y_train)

# Evaluate the Model
y_pred = clf.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print(f"Model Accuracy: {accuracy:.2f}")

#TRAINING MODEL
x= vectorizer.fit_transform(patterns)
y=tags
clf.fit(x,y)

import random

def chatbot(input_text):
    # Transform the input text into the same format as the training data
    input_vector = vectorizer.transform([input_text])

    # Predict the tag using the trained model
    predicted_tag = clf.predict(input_vector)[0]

    # Search for a matching response in the training data
    for entry in training_data:
        if entry['output (string)'] == predicted_tag:
            # Return a random response from matching entries
            return random.choice(entry['output (string)'])  # If multiple responses exist for a tag

    return "I'm sorry, I don't understand that question."  # Fallback response if no match is found

#chatbot using streamlit

counter=0
def main():
    global counter
    st.title("MENSTRUAL HEALTH AWARNESS BOT")
    st.write("WELCOME TO THE CHATBOT")
    counter+=1
    user_input=st.text_input("you:",key=f"user_input_{counter}")

    if user_input:
        response=chatbot(user_input)
        st.text_area("chatbot:", value=response, height=100, max_chars=None, key= f"chatbot_response_{counter}")
        if response.lower()in ['goodbye', 'bye']:
            st.write("Thanks!!")
            st.stop()
if __name__=='__main__':
    main()